---
/**
 * 弹窗组件 - 优化版本
 * 
 * 功能特性:
 * - 支持多种主题和位置
 * - 自动关闭和倒计时
 * - 跟随滚动和响应式
 * - 完善的错误处理和性能优化
 * - 可访问性支持
 * 
 * 使用方法:
 * ```astro
 * ---
 * import Popup from '../components/Popup/Popup.astro';
 * ---
 * 
 * <Popup
 *   title="系统公告"
 *   content="这是一条重要公告信息！"
 *   theme="primary"
 *   autoClose={true}
 *   autoCloseTime={5000}
 * />
 * ```
 */

// 弹窗主题类型定义
type PopupTheme = 'light' | 'dark' | 'primary' | 'success' | 'warning' | 'danger';

// 弹窗位置类型定义
type PopupPosition = 'center' | 'top' | 'bottom' | 'float';

// 回调函数类型定义
type PopupCallback = () => void;

// 组件属性接口
export interface Props {
  title?: string;                    // 弹窗标题
  content?: string;                  // 弹窗内容，支持HTML（可选，也可以使用插槽）
  theme?: PopupTheme;                // 弹窗主题
  showCloseButton?: boolean;         // 是否显示关闭按钮
  autoClose?: boolean;               // 是否自动关闭
  autoCloseTime?: number;            // 自动关闭时间(毫秒)
  id?: string;                       // 弹窗ID，用于区分多个弹窗
  width?: string;                    // 弹窗宽度，如 '400px'、'50%' 等
  position?: PopupPosition;          // 弹窗位置
  closeOnBackdrop?: boolean;         // 点击背景是否关闭弹窗
  showOnLoad?: boolean;              // 页面加载后是否自动显示
  delay?: number;                    // 显示延迟时间(毫秒)
  followScroll?: boolean;            // 是否跟随滚动条
  offsetX?: number;                  // X轴偏移量(px)
  offsetY?: number;                  // Y轴偏移量(px)
  showButtons?: boolean;             // 是否显示底部按钮
  primaryButtonText?: string;        // 主按钮文本
  secondaryButtonText?: string;      // 次按钮文本
  primaryButtonUrl?: string;         // 主按钮链接
  secondaryButtonUrl?: string;       // 次按钮链接
  onOpen?: PopupCallback;            // 打开回调
  onClose?: PopupCallback;           // 关闭回调
  onBeforeClose?: PopupCallback;     // 关闭前回调
}

// 常量定义
const CONSTANTS = {
  ANIMATION_DURATION: 300,          // 动画持续时间(ms)
  DEBOUNCE_DELAY: 16,               // 防抖延迟(ms) ~60fps
  FOCUS_DELAY: 100,                 // 焦点设置延迟(ms)
  COUNTDOWN_INTERVAL: 1000,         // 倒计时更新间隔(ms)
  DEFAULT_AUTO_CLOSE_TIME: 5000,    // 默认自动关闭时间(ms)
  DEFAULT_DELAY: 500,               // 默认显示延迟(ms)
  DEFAULT_OFFSET: 20,               // 默认偏移量(px)
  MAX_WIDTH_PERCENTAGE: 90,         // 最大宽度百分比
  MAX_HEIGHT_PERCENTAGE: 100,        // 最大高度百分比
  Z_INDEX_BACKDROP: 9998,           // 背景层级
  Z_INDEX_POPUP: 9999,              // 弹窗层级
  MIN_AUTO_CLOSE_TIME: 1000,        // 最小自动关闭时间(ms)
  MAX_AUTO_CLOSE_TIME: 60000,       // 最大自动关闭时间(ms)
  MIN_DELAY: 0,                     // 最小延迟时间(ms)
  MAX_DELAY: 10000,                 // 最大延迟时间(ms)
  MIN_WIDTH: 200,                   // 最小宽度(px)
  MAX_WIDTH: 1200                   // 最大宽度(px)
} as const;

// 生成唯一ID的函数
const generateUniqueId = (): string => {
  return 'popup-' + Math.random().toString(36).substring(2, 9) + '-' + Date.now().toString(36);
};

// 参数验证函数
const validateProps = (props: Props): void => {
  if (props.autoCloseTime && props.autoCloseTime < 1000) {
    console.warn('Popup: autoCloseTime should be at least 1000ms for better user experience');
  }
  if (props.delay && props.delay < 0) {
    console.warn('Popup: delay should be a positive number');
  }
  
  // 检查width属性是否有效
  if (props.width) {
    // 如果是数字，则视为有效（后面会自动添加px单位）
    if (typeof props.width === 'number') {
      return;
    }
    
    // 如果是字符串，检查是否包含有效的CSS单位或者是"auto"
    if (typeof props.width === 'string') {
      const trimmedWidth = props.width.trim();
      
      // 检查是否为"auto"
      if (trimmedWidth === 'auto') {
        return;
      }
      
      // 检查是否是CSS函数（如min(), max(), clamp()等）
      const cssFunctionPattern = /^(min|max|clamp|calc|fit-content|env|var)\s*\([^)]*\)$/;
      if (cssFunctionPattern.test(trimmedWidth)) {
        return;
      }
      
      // 检查是否包含有效的CSS单位
      const validUnits = ['px', '%', 'em', 'rem', 'vw', 'vh', 'vmin', 'vmax', 'cm', 'mm', 'in', 'pt', 'pc'];
      const hasValidUnit = validUnits.some(unit => trimmedWidth.endsWith(unit));
      
      // 如果没有单位，检查是否可以转换为数字（后面会自动添加px单位）
      if (!hasValidUnit) {
        const numValue = parseFloat(trimmedWidth);
        if (!isNaN(numValue)) {
          return;
        }
      }
      
      // 如果以上条件都不满足，则发出警告
      console.warn('Popup: width should be a valid CSS unit (px, %, em, rem, vw, vh, vmin, vmax, cm, mm, in, pt, pc), CSS function (min(), max(), clamp(), calc(), etc.) or "auto"');
    }
  }
};

// 默认属性值
const {
  title = '',
  content,
  theme = 'light',
  showCloseButton = true,
  autoClose = false,
  autoCloseTime = CONSTANTS.DEFAULT_AUTO_CLOSE_TIME,
  id = generateUniqueId(),
  width = 'auto',
  position = 'center' as PopupPosition,
  closeOnBackdrop = true,
  showOnLoad = true,
  delay = CONSTANTS.DEFAULT_DELAY,
  followScroll = false,
  offsetX = CONSTANTS.DEFAULT_OFFSET,
  offsetY = CONSTANTS.DEFAULT_OFFSET,
  showButtons = false,
  primaryButtonText = '立即购买',
  secondaryButtonText = '联系客服',
  primaryButtonUrl = '/pricing',
  secondaryButtonUrl = '#contact',
  onOpen,
  onClose,
  onBeforeClose
} = Astro.props as Props;

// 验证属性
validateProps(Astro.props);

// 处理width属性，确保它有有效的CSS单位
const processedWidth = (() => {
  // 如果width是数字，默认添加px单位
  if (typeof width === 'number') {
    return `${width}px`;
  }
  
  // 如果width是字符串，检查是否包含有效的CSS单位
  if (typeof width === 'string') {
    // 移除可能的空格
    const trimmedWidth = width.trim();
    
    // 检查是否是CSS函数（如min(), max(), clamp()等）
    const cssFunctionPattern = /^(min|max|clamp|calc|fit-content|env|var)\s*\([^)]*\)$/;
    if (cssFunctionPattern.test(trimmedWidth)) {
      return trimmedWidth;
    }
    
    // 检查是否已经包含有效的CSS单位
    const validUnits = ['px', '%', 'em', 'rem', 'vw', 'vh', 'vmin', 'vmax', 'cm', 'mm', 'in', 'pt', 'pc'];
    const hasValidUnit = validUnits.some(unit => trimmedWidth.endsWith(unit));
    
    if (hasValidUnit) {
      return trimmedWidth;
    }
    
    // 如果没有单位，尝试转换为数字并添加px单位
    const numValue = parseFloat(trimmedWidth);
    if (!isNaN(numValue)) {
      return `${numValue}px`;
    }
  }
  
  // 默认宽度
  return 'auto';
})();

// 根据位置设置样式类
const positionClasses: Record<PopupPosition, string> = {
  'center': 'top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2',
  'top': 'top-4 left-1/2 -translate-x-1/2',
  'bottom': 'bottom-4 left-1/2 -translate-x-1/2',
  'float': 'right-[20px] bottom-[20px]'
};
const positionClass = positionClasses[position];

// 是否使用固定定位
const positionType = followScroll ? 'absolute' : 'fixed';
---

<style>
  /* 动画效果 - 优化滚动时的平滑度 */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  
  @keyframes scaleIn {
    from { transform: translate(-50%, -50%) scale(0.9); }
    to { transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes scaleOut {
    from { transform: translate(-50%, -50%) scale(1); }
    to { transform: translate(-50%, -50%) scale(0.9); }
  }
  
  .popup {
    opacity: 0;
    display: none;
    /* 添加硬件加速和平滑过渡 */
    will-change: transform, opacity;
    backface-visibility: hidden;
    transform-style: preserve-3d;
    /* 优化滚动时的位置过渡 */
    transition: top 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                left 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  
  .popup.show {
    display: block;
    animation: fadeIn 0.3s forwards;
  }
  
  .popup.hide {
    animation: fadeOut 0.3s forwards;
  }
  
  .popup-center.show {
    animation: fadeIn 0.3s forwards, scaleIn 0.3s forwards;
  }
  
  .popup-center.hide {
    animation: fadeOut 0.3s forwards, scaleOut 0.3s forwards;
  }
  
  /* 滚动时禁用过渡动画以避免拖拉感 */
  .popup.scrolling {
    transition: none;
  }
  
  .backdrop {
    opacity: 0;
    display: none;
  }
  
  .backdrop.show {
    display: block;
    animation: fadeIn 0.3s forwards;
  }
  
  .backdrop.hide {
    animation: fadeOut 0.3s forwards;
  }
  
  /* 主题颜色 */
  .theme-light {
    --bg-color: #ffffff;
    --text-color: #333333;
    --close-hover: rgba(0, 0, 0, 0.05);
  }
  
  .theme-dark {
    --bg-color: #333333;
    --text-color: #ffffff;
    --close-hover: rgba(255, 255, 255, 0.1);
  }
  
  .theme-primary {
    --bg-color: #1976d2;
    --text-color: #ffffff;
    --close-hover: rgba(255, 255, 255, 0.1);
  }
  
  .theme-success {
    --bg-color: #4caf50;
    --text-color: #ffffff;
    --close-hover: rgba(255, 255, 255, 0.1);
  }
  
  .theme-warning {
    --bg-color: #ff9800;
    --text-color: #ffffff;
    --close-hover: rgba(255, 255, 255, 0.1);
  }
  
  .theme-danger {
    --bg-color: #f44336;
    --text-color: #ffffff;
    --close-hover: rgba(255, 255, 255, 0.1);
  }
</style>

<!-- 弹窗HTML结构 -->
<div 
  id={`${id}-backdrop`}
  class={`backdrop fixed inset-0 bg-black/50 ${followScroll ? 'hidden' : ''}`}
  style={`z-index: ${CONSTANTS.Z_INDEX_BACKDROP};`}
  role="presentation"
  aria-hidden="true"
></div>

<div 
  id={id}
  class={`popup popup-${position === 'center' ? 'center' : ''} ${positionType} ${positionClass} rounded-2xl shadow-lg theme-${theme}`}
  role="dialog"
  aria-labelledby={title ? `${id}-title` : undefined}
  aria-describedby={content ? `${id}-content` : undefined}
  aria-modal={!followScroll}
  style={`background-color: var(--bg-color); color: var(--text-color); max-width: ${CONSTANTS.MAX_WIDTH_PERCENTAGE}%; max-height: ${CONSTANTS.MAX_HEIGHT_PERCENTAGE}vh; width: ${processedWidth}; overflow-y: auto; z-index: ${CONSTANTS.Z_INDEX_POPUP};`}
>
  <div class="relative p-5">
    {title && <h3 id={`${id}-title`} class="text-lg font-semibold mb-3 pr-8 text-center pt-4">{title}</h3>}
    
    <div id={`${id}-content`} class="text-sm leading-relaxed">
      {content ? <div set:html={content}></div> : <slot />}
    </div>
    
    {showCloseButton && (
      <button 
        class="absolute top-3 right-3 w-6 h-6 flex items-center justify-center rounded-full text-xl hover:bg-black/5 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        style="hover:background-color: var(--close-hover);"
        aria-label="关闭"
        id={`${id}-close`}
      >
        &times;
      </button>
    )}
    
    {showButtons && (
      <div class="mt-6 flex flex-row gap-3 sm:gap-6 justify-center pb-10">
        <a 
          href={primaryButtonUrl} 
          class="px-6 sm:px-12 py-2 sm:py-3 bg-primary-600 hover:bg-primary-700 text-white font-medium rounded-md transition-all duration-200 transform hover:-translate-y-1 text-center text-sm sm:text-lg"
        >
          {primaryButtonText}
        </a>
        <a 
          href={secondaryButtonUrl} 
          class="px-6 sm:px-12 py-2 sm:py-3 bg-white hover:bg-gray-100 text-primary-600 border border-primary-600 font-medium rounded-md transition-all duration-200 transform hover:-translate-y-1 text-center text-sm sm:text-lg"
        >
          {secondaryButtonText}
        </a>
      </div>
    )}
    
    {autoClose && (
      <div class="mt-4 text-xs text-center opacity-60" id={`${id}-countdown`}></div>
    )}
  </div>
</div>

<script define:vars={{ id, autoClose, autoCloseTime, closeOnBackdrop, showOnLoad, delay, followScroll, offsetX, offsetY, position, onOpen, onClose, onBeforeClose }}>
  document.addEventListener('DOMContentLoaded', () => {
    // 常量定义
    const CONSTANTS = {
      ANIMATION_DURATION: 300,
      DEBOUNCE_DELAY: 8,  // 减少防抖延迟以提高响应性
      FOCUS_DELAY: 100,
      COUNTDOWN_INTERVAL: 1000,
      SCROLL_THRESHOLD: 5,  // 滚动阈值，用于检测是否在滚动
      SCROLL_END_DELAY: 150  // 滚动结束检测延迟
    };
    
    // 获取弹窗元素
    const popup = document.getElementById(id);
    const backdrop = document.getElementById(`${id}-backdrop`);
    const closeButton = document.getElementById(`${id}-close`);
    const countdownElement = document.getElementById(`${id}-countdown`);
    
    // 错误处理：检查必要元素是否存在
    if (!popup) {
      console.error(`Popup: Element with id "${id}" not found`);
      return;
    }
    
    if (!backdrop) {
      console.error(`Popup: Backdrop element with id "${id}-backdrop" not found`);
      return;
    }
    
    // 状态变量
    let timerAutoClose = null;
    let countdownInterval = null;
    let isClosing = false;
    let isOpening = false;
    let lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    let isScrolling = false;
    let scrollEndTimer = null;
    let requestAnimationId = null;
    
    // 防抖函数
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };
    
    // 安全执行回调函数
    const safeExecuteCallback = (callback, context = 'callback') => {
      if (typeof callback === 'function') {
        try {
          callback();
        } catch (error) {
          console.error(`Popup: Error executing ${context}:`, error);
        }
      }
    };
    
    // 跟随滚动功能
    if (followScroll) {
      // 初始位置设置
      updatePopupPosition();
      
      // 优化的滚动事件处理
      const handleScroll = () => {
        if (!popup || !popup.classList.contains('show')) return;
        
        const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollDelta = Math.abs(currentScrollTop - lastScrollTop);
        
        // 检测是否在滚动
        if (scrollDelta > CONSTANTS.SCROLL_THRESHOLD) {
          if (!isScrolling) {
            isScrolling = true;
            popup.classList.add('scrolling');
          }
          
          // 清除之前的滚动结束计时器
          if (scrollEndTimer) {
            clearTimeout(scrollEndTimer);
          }
          
          // 使用 requestAnimationFrame 优化性能
          if (requestAnimationId) {
            cancelAnimationFrame(requestAnimationId);
          }
          
          requestAnimationId = requestAnimationFrame(() => {
            updatePopupPosition();
          });
          
          // 设置滚动结束检测
          scrollEndTimer = setTimeout(() => {
            isScrolling = false;
            popup.classList.remove('scrolling');
          }, CONSTANTS.SCROLL_END_DELAY);
        }
      };
      
      // 防抖优化的窗口大小变化监听
      const debouncedResizeHandler = debounce(() => {
        if (popup && popup.classList.contains('show')) {
          updatePopupPosition();
        }
      }, CONSTANTS.DEBOUNCE_DELAY);
      
      // 添加事件监听器
      window.addEventListener('scroll', handleScroll, { passive: true });
      window.addEventListener('resize', debouncedResizeHandler, { passive: true });
      
      // 保存事件处理器引用以便清理
      window[`${id}_scrollHandler`] = handleScroll;
      window[`${id}_resizeHandler`] = debouncedResizeHandler;
    }
    
    // 更新弹窗位置 - 优化版本
    function updatePopupPosition() {
      try {
        if (!popup) {
          console.warn('Popup: Cannot update position, popup element not found');
          return;
        }
        
        const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        
        // 安全获取弹窗尺寸
        let popupRect;
        try {
          popupRect = popup.getBoundingClientRect();
        } catch (error) {
          console.warn('Popup: Cannot get popup dimensions:', error);
          return;
        }
        
        // 边界检查
        const safeOffsetX = Math.max(0, Math.min(offsetX, windowWidth - 100));
        const safeOffsetY = Math.max(0, Math.min(offsetY, windowHeight - 100));
        
        // 缓存当前样式值以避免重复设置
        const currentTop = popup.style.top;
        const currentLeft = popup.style.left;
        const currentTransform = popup.style.transform;
        
        // 根据滚动方向和位置调整弹窗位置
        if (position === 'float') {
          // 浮动在右下角，跟随滚动
          const newBottom = `${safeOffsetY}px`;
          const newRight = `${safeOffsetX}px`;
          
          if (popup.style.bottom !== newBottom) popup.style.bottom = newBottom;
          if (popup.style.right !== newRight) popup.style.right = newRight;
        } else if (followScroll) {
          // 其他位置但启用了跟随滚动
          switch(position) {
            case 'top':
              const newTopValue = `${Math.max(safeOffsetY, currentScrollTop + safeOffsetY)}px`;
              if (currentTop !== newTopValue) {
                popup.style.top = newTopValue;
              }
              break;
            case 'bottom':
              const newBottomValue = `${safeOffsetY}px`;
              if (popup.style.bottom !== newBottomValue) {
                popup.style.bottom = newBottomValue;
              }
              break;
            case 'center':
            default:
              // 居中但跟随滚动，确保不超出视窗
              const maxPopupHeight = windowHeight * 0.8; // 限制弹窗最大高度为视窗的80%
              const actualHeight = Math.min(popupRect.height, maxPopupHeight);
              const centerTop = currentScrollTop + (windowHeight / 2);
              const minTop = currentScrollTop + safeOffsetY + (actualHeight / 2);
              const maxTop = currentScrollTop + windowHeight - safeOffsetY - (actualHeight / 2);
              
              // 确保弹窗始终在可视区域内居中
              const finalTop = Math.max(minTop, Math.min(centerTop, maxTop));
              const newTopPos = `${finalTop}px`;
              const newLeftPos = '50%';
              const newTransformValue = 'translate(-50%, -50%)';
              
              // 只在值发生变化时更新样式
              if (currentTop !== newTopPos) popup.style.top = newTopPos;
              if (currentLeft !== newLeftPos) popup.style.left = newLeftPos;
              if (currentTransform !== newTransformValue) popup.style.transform = newTransformValue;
              
              // 如果内容过高，启用滚动
              if (popupRect.height > maxPopupHeight) {
                const newMaxHeight = `${maxPopupHeight}px`;
                if (popup.style.maxHeight !== newMaxHeight) {
                  popup.style.maxHeight = newMaxHeight;
                  popup.style.overflowY = 'auto';
                }
              }
              break;
          }
        }
        
        lastScrollTop = currentScrollTop;
      } catch (error) {
        console.error('Popup: Error updating position:', error);
      }
    }
    
    // 打开弹窗
    function openPopup() {
      try {
        if (isOpening) {
          console.warn('Popup: Already opening, ignoring duplicate call');
          return;
        }
        
        if (!backdrop || !popup) {
          console.error('Popup: Required elements not found');
          return;
        }
        
        isOpening = true;
        
        // 如果正在关闭，取消关闭动画
        if (isClosing) {
          popup.classList.remove('hide');
          backdrop.classList.remove('hide');
          isClosing = false;
        }
        
        // 显示弹窗
        popup.classList.add('show');
        backdrop.classList.add('show');
        
        // 执行打开回调
         safeExecuteCallback(onOpen, { id, popup, backdrop });
        
        // 设置焦点到弹窗（提高可访问性）
        if (closeButton) {
          setTimeout(() => closeButton.focus(), CONSTANTS.FOCUS_DELAY);
        }
        
        // 如果启用自动关闭
        if (autoClose && autoCloseTime > 0) {
          let remainingTime = autoCloseTime;
          
          // 更新倒计时显示
          if (countdownElement) {
            countdownElement.textContent = `${Math.ceil(remainingTime / 1000)}秒后自动关闭`;
            
            countdownInterval = setInterval(() => {
              remainingTime -= CONSTANTS.COUNTDOWN_INTERVAL;
              if (remainingTime <= 0) {
                clearInterval(countdownInterval);
                return;
              }
              
              if (countdownElement) {
                countdownElement.textContent = `${Math.ceil(remainingTime / 1000)}秒后自动关闭`;
              }
            }, CONSTANTS.COUNTDOWN_INTERVAL);
          }
          
          // 设置自动关闭定时器
          timerAutoClose = setTimeout(() => {
            closePopup();
          }, autoCloseTime);
        }
        
        isOpening = false;
      } catch (error) {
        console.error('Popup: Error in openPopup:', error);
        isOpening = false;
      }
    }
    
    // 隐藏弹窗
    function hidePopup() {
      try {
        if (!popup || !backdrop) {
          console.error('Popup: Required elements not found');
          return;
        }
        
        // 执行关闭前回调
        safeExecuteCallback(onBeforeClose, { id, popup, backdrop });
        
        backdrop.classList.add('hide');
        popup.classList.add('hide');
        
        setTimeout(() => {
          try {
            backdrop.classList.remove('show', 'hide');
            popup.classList.remove('show', 'hide');
            
            // 执行关闭回调
            safeExecuteCallback(onClose, { id, popup, backdrop });
          } catch (error) {
            console.error('Popup: Error in hidePopup timeout:', error);
          }
        }, CONSTANTS.ANIMATION_DURATION);
        
        // 清除定时器
        if (timerAutoClose) {
          clearTimeout(timerAutoClose);
          timerAutoClose = null;
        }
        
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
      } catch (error) {
        console.error('Popup: Error in hidePopup:', error);
      }
    }
    
    // 清理函数 - 清理所有定时器和事件监听器
    function cleanup() {
      try {
        // 清除所有定时器
        if (timerAutoClose) {
          clearTimeout(timerAutoClose);
          timerAutoClose = null;
        }
        
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
        
        if (scrollEndTimer) {
          clearTimeout(scrollEndTimer);
          scrollEndTimer = null;
        }
        
        if (requestAnimationId) {
          cancelAnimationFrame(requestAnimationId);
          requestAnimationId = null;
        }
        
        // 移除滚动状态类
        if (popup) {
          popup.classList.remove('scrolling');
        }
        
        // 重置滚动状态
        isScrolling = false;
        
      } catch (error) {
        console.error('Popup: Error during cleanup:', error);
      }
    }
    
    // 关闭弹窗
    function closePopup() {
      try {
        if (isClosing) {
          console.warn('Popup: Already closing, ignoring duplicate call');
          return;
        }
        
        if (!popup || !backdrop) {
          console.error('Popup: Required elements not found');
          return;
        }
        
        // 执行关闭前回调
         safeExecuteCallback(onBeforeClose, { id, popup, backdrop });
        
        // 标记正在关闭
        isClosing = true;
        
        // 清理所有定时器和状态
        cleanup();
        
        // 添加关闭动画
        popup.classList.add('hide');
        backdrop.classList.add('hide');
        
        // 动画结束后隐藏元素
        setTimeout(() => {
          if (isClosing) {
            popup.classList.remove('show', 'hide');
            backdrop.classList.remove('show', 'hide');
            isClosing = false;
            
            // 执行关闭回调
             safeExecuteCallback(onClose, { id, popup, backdrop });
          }
        }, CONSTANTS.ANIMATION_DURATION);
        
      } catch (error) {
        console.error('Popup: Error in closePopup:', error);
        isClosing = false;
      }
    }
    
    // 添加关闭按钮事件
    if (closeButton) {
      closeButton.addEventListener('click', closePopup);
    }
    
    // 添加背景点击关闭事件
    if (closeOnBackdrop) {
      backdrop.addEventListener('click', closePopup);
    }
    
    // 添加ESC键关闭事件
    function handleEscKey(e) {
      if (e.key === 'Escape' && popup.classList.contains('show')) {
        closePopup();
      }
    }
    
    document.addEventListener('keydown', handleEscKey);
    
    // 全局清理函数 - 移除事件监听器和清理资源
    function globalCleanup() {
      try {
        // 清除定时器
        if (timerAutoClose) {
          clearTimeout(timerAutoClose);
          timerAutoClose = null;
        }
        
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
        
        if (scrollEndTimer) {
          clearTimeout(scrollEndTimer);
          scrollEndTimer = null;
        }
        
        if (requestAnimationId) {
          cancelAnimationFrame(requestAnimationId);
          requestAnimationId = null;
        }
        
        // 移除跟随滚动的事件监听器
        if (followScroll) {
          const scrollHandler = window[`${id}_scrollHandler`];
          const resizeHandler = window[`${id}_resizeHandler`];
          
          if (scrollHandler) {
            window.removeEventListener('scroll', scrollHandler);
            delete window[`${id}_scrollHandler`];
          }
          
          if (resizeHandler) {
            window.removeEventListener('resize', resizeHandler);
            delete window[`${id}_resizeHandler`];
          }
        }
        
        // 移除键盘事件监听器
        document.removeEventListener('keydown', handleEscKey);
        
        // 移除按钮事件监听器
        if (closeButton) {
          closeButton.removeEventListener('click', closePopup);
        }
        
        if (closeOnBackdrop) {
          backdrop.removeEventListener('click', closePopup);
        }
        
        console.log(`Popup ${id}: Global cleanup completed`);
      } catch (error) {
        console.error('Popup: Error during global cleanup:', error);
      }
    }
    
    // 页面卸载时清理资源
    window.addEventListener('beforeunload', globalCleanup);
    
    // 页面加载后显示弹窗
    if (showOnLoad) {
      if (delay > 0) {
        setTimeout(openPopup, delay);
      } else {
        openPopup();
      }
    }
    
    // 将弹窗控制函数暴露给全局
    window[`${id}Control`] = {
      open: openPopup,
      close: closePopup
    };
    

  });
</script>
